# LostAndFound

## 目录

- 简介
- 项目链接
- 后端仓库
- 技术选型
- 功能
- 技术点
- 项目收获
- Project setup

## 简介

一个社区失物招领信息网站，使用Vue + ElementUI + ali-oss等开发

## 项目链接

点击跳转：[laf (timegogo.top)](https://www.timegogo.top/laf/#/lost)

## 后端仓库

仓库地址：[Qiuzcc/LAFBackend: 社区失物招领网站LostAndFound的后端代码 (github.com)](https://github.com/Qiuzcc/LAFBackend

## 技术选型

| 技术          | 用途                                   |
| ------------- | -------------------------------------- |
| Vue2          | 渐进式 JavaScript 框架                 |
| Vue CLI 4.4.6 | Vue脚手架工具                          |
| Vue Router 3  | 路由管理器                             |
| Vuex 3        | 状态管理模式库                         |
| Element UI    | UI组件库                               |
| Axios         | HTTP 库                                |
| nprogress     | 轻量的进度条组件                       |
| ali-oss       | oss上传工具                            |
| Express       | Node.js Web 应用程序框架               |
| mongoose      | 针对node.js环境的MongoDB对象文档模型库 |
| jsonwebtoken  | token技术解决方案                      |
| MongoDB       | 基于分布式文件存储的数据库             |

选择Vue2，而没有选择Vue3的原因如下：

1. Vue2的历史悠久，但是目前并未完全过时，因为生态没有即使配置升级的原因，导致Vue2到Vue3的升级兼容得不好，很多旧项目依然使用Vue2而没有升级Vue3，所以还存在Vue2的使用场景
2. 相比于Vue3，Vue2的项目更多、教程更加完善，对于新手入门学习更加友好。而且前期学习的所有案例、教程都是基于Vue2的，如果此时再去学Vue3，可能导致前者没掌握、后者没学好，所以干脆先学Vue2
3. 即使Vue3对比Vue2的革新很大，但是大部分原理是相通的，掌握Vue2的原理对上手Vue3也有帮助；掌握Vue2的用法有助于理解Vue3的用法
4. 升级式学习顺序，先学Vue2再学Vue3感觉更肉更合理。先学Vue3再倒过头来查阅Vue2感觉怪怪的

选择Express的原因：

1. 选择nodejs而没有选择Java，虽然Java据说性能更强，但是学习曲线更加陡峭，需要投入的时间更多。我主要是学前端的，学习后端的技能只是为了配合前端，所以nodejs显然是更好的选择，因为它使用JavaScript
2. Express是一个比较容易上手的nodejs框架，能够快速搭建起后端服务器。而且之前在教程中学习使用过，上手成本更低。

## 功能

- 浏览失物招领、寻物启事信息
- 查看信息详情
- 验证身份查看联系信息
- 用户管理，登陆管理、修改个人信息

![image-20220906104052649](https://qiuzcc-typora-images.oss-cn-shenzhen.aliyuncs.com/images/2022/202209061040810.png)

![image-20220906104138417](https://qiuzcc-typora-images.oss-cn-shenzhen.aliyuncs.com/images/2022/202209061041525.png)

![image-20220906104215904](https://qiuzcc-typora-images.oss-cn-shenzhen.aliyuncs.com/images/2022/202209061042045.png)

![image-20220906104249897](https://qiuzcc-typora-images.oss-cn-shenzhen.aliyuncs.com/images/2022/202209061042057.png)

<img src="https://qiuzcc-typora-images.oss-cn-shenzhen.aliyuncs.com/images/2022/202209061043381.png" alt="image-20220906104318344" style="zoom:50%;" /><img src="https://qiuzcc-typora-images.oss-cn-shenzhen.aliyuncs.com/images/2022/202209061043444.png" alt="image-20220906104333410" style="zoom:50%;" />

[^注]: 图文无关，网站目前内容仅为测试时录入的信息，不是正式信息

## 技术点

- **前后端接口（方法、数据格式）对接**，依靠文档进行统一

- **页面权限管理**

  分为前端导航权限管理、后端url权限管理

  前端通过设置全局导航守卫实现，在进行每次导航路由跳转之前，检查本地有无token：

  1. 有token，允许所有导航
  2. 没有token，判断导航目标路由是否在白名单内。在，允许跳转；不在，重定向到登陆页面

  后端通过在所有路由之前设置验证函数实现（目前没有实际使用），第一步，判断当前url是否在白名单内

  1. 在，通过
  2. 不在，验证请求头中是否有token，以及token是否有效。有效，通过；无效，返回401状态码，要求重新登陆验证

- **记录用户登陆状态、辨别用户身份**

  通过token实现，在后端使用jsonwebtoken库进行token管理，用户通过登陆验证后，根据usename生成一个token并返回到客户端；客户端本地保存token，在有效期内有token可以免登陆；客户端所有请求携带上token信息，后端在验证token时可以识别出username，据此识别用户身份

  客户端本地保存token一开始使用cookie，但是在项目构建之后，出现了cookie失效的问题，所以更换为使用localStorage。但是localStorage有一个特点：它是永久储存，但是token是会过期的，所以在自定义函数中需要对localStorage的储存完善一下，除了token之后，还要保存一个过期时间戳；在获取token的时候进行判断是否过期。

- **自定义组件的数据流**

  数据流处理复杂的一个自定义组件，用户头像组件。场景：父组件要传递一个异步获取的url给Avatar组件，Avator组件里这个url变量存在修改的需求，Avatar的url参数可能需要传递给父组件。首先考虑第二点，url可能被修改，所以不能通过prop参数直接传递（这样修改之后会报错），所以需要在data中创建一个替代变量，在created生命周期函数中用prop参数给data变量赋值。但这有一个前提，就是Avatar组件被创建渲染时，url参数必须已经存在了，所以url不能异步获取，必须把获取url、创建Avatar转换成同步操作。第三点，就是常规操作，通过$emit方法把变量连同函数接口一起传递给父组件即可

- **OSS上传服务的搭建**

  ElementUI的el-upload组件自带了默认的上传服务，但是没有使用它，因为默认的上传服务中没有我使用的云对象储存服务。严格上这不属于前端的技术范畴，但是确实业务中不可或缺的一部分，相比起把照片发送到后端再上传，在前端上传可以节省一次多余的传递过程。如果上传服务的网速不是明显低于后端api的网速的话，在客户端体验是没有差异。配置过程比较繁琐复杂，第一步，在阿里云控制台创建一个RAM用户和一个角色；第二步，在后端创建一个STS（Security Token Service）临时访问权限管理服务（在这一步踩坑了，一开始以为在客户端环境中可以运行这个库，但是频频报错；后来才发觉这个库只能运行在后端node.js环境中）；第三步，在前端请求STS、创建一个oss实例，把获取的file文件上传

- **创建安全的数据库连接**

  偏向于后端的技术范畴了。该项目使用的数据库部署到云服务器上，与后端在同一台服务器上，在生产环境中理论上是没有安全风险的，因为后端与数据库通过内网进行通信。但是为了方便开发过程中，在本地使用UI界面对数据库进行监视和修改，所以为数据库设置了一个用户验证（MongoDB默认是没有用户验证的）。在之前的练手项目中，因为没有设置设置用户验证同时将端口开放到了公网中，所以数据库被攻击篡改了。

- **项目部署**

  项目部署采用了简单的处理方式，在本地编译打包之后，将打包好的项目代码通过Xftp上传到服务器指定路径。设置Apache代理（在CentOS7中为httpd，DocumentRoot为hexo博客的目录，即我的主页对应的是我的hexo博客），添加一个二级路径，通过设置Alias，指定一个二级路径网址链接到项目代码路径，实现：通过网站二级路径可以访问到项目。

- **将后端api设置为ssl安全链接**

  项目部署上线之后遇到一个很大的问题，因为项目的网址使用的https协议，而后端api的网址是http协议的，所以导致浏览器因为安全策略限制了对后端api的请求，导致无法获取到数据，并且无法交互。解决办法是通过Apache设置一个反向代理，将本地3000端口（后端api）对应到一个二级路径上，这样就可以通过https协议来访问后端api了。

- **el-menu组件动态响应路由变化**

  还没有实现，目前存在一个bug，导航菜单不能跟踪路由的变化。比如通过全局路由对象进行跳转到路由，导航菜单监听不到，也就不能根据当前的路由改变default-active项

- **嵌套路由**

  有一些前缀相同的子级路由，可以写成嵌套路由的形式，即

  ```javascript
  const route = [{
      path:'/laf/home/found',
      component:...
  },{
      path:'/laf/home/found/detail/:id'
      component:...
  },...]
  ```

  可以写成：

  ```javascript
  const route = [{
      path:'/laf/home/found',
      component:...
      children:[{
      	path:'',
      	component;...
  	},{
          path:'/detail/:id',
          component:...
      }]
  },...]
  ```

  达到减少重复代码的效果，但是有一点需要注意：就是每一级路由的component属性都不能为空，即使没有任何内容，都需要用一个router-view占位

- **PostMan测试**

  通过PostMan测试后端api，PostMan是一个很有用的api测试工具，可以模拟各种Request请求。如果在前端直接测试api，将会很麻烦，很多问题难以区分是前端的问题还是后端的问题。通过PostMan，可以在前端使用api之前，确保api没有任何问题（如果有问题就是后端的问题）。PostMan的使用也有技巧，如通过脚本设置环境变量、根据项目设置不同的Collections，方便快速测试。

## 项目收获

- 完整实践了一遍项目的开发全流程

  从项目规划（制定功能、技术选型、设计数据结构、api）、到编程开发、到构建部署上线，完整地经历了整个项目开发流程（团队协作除外，怎么协作、处理各种冲突也是很关键的一环）

  独立完成了前、后端部分，**对于前后端的协作方式有自己的实际体会**。项目规划的时候做了一次api设计，对url和requeset和response的数据结构做了一个设计，参照了RESTful API的做法。不过在实际开发中（按照功能点开发，开发一个功能，先完成它的后端部分、再完成它的前端部分），会发生临时因为功能需要增删改变量的情况，因为是自己完成前后端，所以一旦发生改变能够在前端和后端同时修改。但是在团队分工开发中，中途修改api就是比较头疼的问题了，如果及时通知的话，就需要停下手中的活，去做修改；如果后面才通知的话，就需要完成之后回溯代码去修改，容易造成修改不充分，产生bug。

  提到修改，**开发过程中记录文档是一个很好的习惯**，把所做的修改、遇到的问题，记录在文档中，就不会出现遗忘的问题，好记性不如烂笔头，当工作愈发复杂时，借助文档来减轻记忆的压力。

  **积累了使用“轮子”的经验**，项目的很多基础功能都是依赖第三方模块实现的，比如axios、ali-oss，使用这些工具的前提是读懂他们都文档、根据文档来使用；项目的UI界面是用ElementUI搭建的，有一些细化的功能只依靠文档无法解决，因为文档不可能写得事无巨细，所以就要去读它的源码，看懂它的原理，然后自定义操作；另外文档没有解答遇到的问题，可以到github的issue里面去查找，你遇到的问题说不定别人已经遇到过了。这应该是比去百度、谷歌搜索更有效的搜寻方式。

  **积累了项目综合开发的能力**，除了开发页面和功能之外，构建、部署也是一个必不可少的环节，这是一个如果熟悉就很简单、如果不熟悉就很复杂的环节。构建包含了打包工具（如webpack）的配置，部署包括了服务器的使用、代理的设置。

  

- 进一步掌握了Vue的用法

  尤其是Vue Router，项目逻辑中涉及到Router的部分比较多，如前置导航守卫、嵌套路由、编程式导航、监听路由。所以对Router的文档研究的次数比较多。在之前的项目中，都是直接复制了项目的写法，很少去思考写法背后的含义。而这一次不一样，因为所有的功能都是自己定义、实现的，所以必须从功能的需求出发去思考代码应该如何写、代码逻辑应该是怎样的。这两者的差别很大，后者的难度大、耗时多、但是掌握的效果会更好。

## Project setup
```
npm install
```

### Compiles and hot-reloads for development
```
npm run serve
```

### Compiles and minifies for production
```
npm run build
```